\documentclass[12pt, titlepage]{ltjsarticle}
\usepackage{luatexja}
\usepackage{bussproofs}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{stmaryrd}
\usepackage{tikz}
\usetikzlibrary{matrix, positioning}
\DeclareMathOperator{\SN}{SN}
\DeclareMathOperator{\Term}{Term}
\DeclareMathOperator{\Obj}{Obj}
\DeclareMathOperator{\Constr}{Constr}
\DeclareMathOperator{\Type}{Type}
\DeclareMathOperator{\Kind}{Kind}
\DeclareMathOperator{\SAT}{SAT}
\DeclareMathOperator{\Set}{Set}
\DeclareMathOperator{\GTerm}{\Gamma-Term}
\DeclareMathOperator{\GObj}{\Gamma-Obj}
\DeclareMathOperator{\GConstr}{\Gamma-Constr}
\DeclareMathOperator{\GType}{\Gamma-Type}
\DeclareMathOperator{\GKind}{\Gamma-Kind}
\DeclareMathOperator{\K}{K}
\DeclareMathOperator{\red}{red}
\newcommand{\iprt}[2]{\llbracket {#1} \rrbracket_ {#2}}
\begin{document}

\theoremstyle{definition}
\newtheorem{defn}{定義}
\newtheorem{thm}{定理}
\newtheorem{lem}{補題}
\newtheorem{rem}{注意}
\newtheorem{cor}{系}
\newtheorem{ex}{例}
\renewcommand{\proofname}{\bf{証明}}

\title{Calculus of Constructionの基本的性質}
\author{
アドバイザー名: Jacques Garrigue
学生番号: 321701183
氏名: 田中 一成
}
\maketitle

% 構成案
%
% 型システムを論理体系とみなすために必要な事実とは
% 合流性 (等式の判定のため)
% 正規性 (?, 不等式の場合にかんがえてみるべき?)
% - equiv. canonicity?
% Subject Reductionをいれるか？
% lambda cubeをみせるか？
% いくつかの主張を型で書いてみるとか？
% - False型 (任意の主張がせいりつする)
% Cocに対応するtheoryを構成するべきか？
% Cocのモデルは必要か？
%  - Scottの方法がつかえるか？
% rewritingについてどれだけのべるか？
% - あまり必要ない？
% - completionはheuristicなので説明しづらい
% - Universal Algebraくらいは述べてもいいかな？
%   - theoryの記述につかえる
% 数学的な記述 vs BNF
% Polymorphic typeの整合性
% - 集合論での矛盾 (Gilard)
% - System Fのモチベーション
%   - Prop as Type
% Intuitionistic logicの歴史はいる?
%
% 適切なReductionを入れることが重要であると私はおもっている...
% - directed homotopy? (わかってないので書かない)
% - よくかんがえたらこの問題意識はcompletion由来かも?

\section{序文}
この文章はCalculus of Construction(CoC)と呼ばれる(数理論理学的な)言語についてのサーベイである.

現在の数学的なコンピュータソフトウェアというものは, おおよそ代数的な計算を行うものであり, しかも特定の領域に特化したアルゴリズムを書く必要がある.
それらは高速で実用的である一方, 再利用性が高いとはいいがたい.

一方でCoCの実際的な価値というのは, 数学的な対象を言語を通じてあらわすことにより, 抽象的な表現をコンピュータ上で行うことができる点にある.
ユースケースとしては, 数学的にはわかりやすいが計算複雑性の観点からはnaiveな定義と, こみいった定義ではあるが計算量が少ないアルゴリズムによる定義があったとき,
それらの同値性を証明によって担保しつつ, 適切なタイミングで読み換えるなどといったことが可能である.

% 型理論の構造としても, 高次元圏のような対象が自然にあらわれるものとして, 興味深いものであるといえる.
% なんかかく

このように項を証明, 型を主張とみなしコンピュータ上で証明を行うことを形式証明とよぶ.

% しかしながら, そのような抽象的な項を作りだすことはかなり忍耐の要請される行いである. 
% 実際, 一見自明に思える事柄でも, 項のレベルでは不合理なまでに複雑になってしまい, 手に終えなくなってしまうことが筆者の経験上多々あった.
% そのような現象が起きてしまう原因は, 証明論的と意味論の隔りにあると筆者は考えた.
% CoCを用いて形式証明を行う際には, 正当化の方法はすべて型づけとよばれる公理に帰着される. 証明が完了すれば, 主張を根とした巨大な木構造が得られるわけである.

% 詳しく述べると, 

本文章では, CoCの論理的な整合性について特に論じる.

また, 本文章の停止性の証明は \cite{geuvers1994short}によるところが大きい.
定理\ref{CR}のCoqによる形式化を付録に付ける.

\section{項書き換え系}
初めに簡約関係と呼ばれる一般の$2$項関係について論じる. 考えている集合$A$とその上の$2$項関係$\rightarrow \subset A \times A$を固定する.ここでそれぞれ,
$\xrightarrow{n}$を$\rightarrow$を$n$回合成した関係,
$\leftrightarrow$を$\rightarrow$の対称閉包,
$\xrightarrow{+}$を$\rightarrow$の推移閉包,
$\xrightarrow{=}$を$\rightarrow$の反射閉包,
$\overset{*}{\rightarrow}$を$\rightarrow$の推移反射閉包,
$\overset{+}{\leftrightarrow}$を$\rightarrow$の推移対称閉包,
$\overset{*}{\leftrightarrow}$を$\rightarrow$の推移対称反射閉包とする.
また$(a, b) \in \rightarrow$を$a \rightarrow b$と書く.

\begin{defn}
$\rightarrow$が合流性を持つとは,任意の$y_{1},y_{2},x \in A$について$y_1 \overset{*}{\leftarrow} x \overset{*}{\rightarrow} y_2$ならば, $y_1 \overset{*}{\rightarrow} z \overset{*}{\leftarrow} y_2$となる$z \in A$が存在することを言い, 停止するとは無限列$a_0 \rightarrow a_1 \rightarrow a_2 \rightarrow \cdots$が$A$に存在しないことを言う. さらに$x \in A$が正規形であるとは, $x \rightarrow y$となる$y \in A$が存在しないことを言う.
\end{defn}

また停止性の非自明な言い換えとしてwell foundednessとよばれるものがある.

\begin{defn}
$\rightarrow$がwell foundedであるとは, 以下の条件が同値であることをいう. ただし$P$は任意の述語を表している.
 \begin{itemize}
  \item 任意の$x \in A$について, $x \xrightarrow{+} y$となる全ての$y \in A$に対して$P(y)$ならば$P(x)$
  \item 任意の$z \in A$について$P(z)$
 \end{itemize}
\end{defn}

\begin{thm}
 停止性とwell foundednessは同値である.
\end{thm}

\begin{proof}
 必要性を示す. 任意の$w \in A$について$P(w):= \text{無限列} w \rightarrow w_1 \rightarrow \cdots \text{は存在しない}$と置く. 任意の$x \xrightarrow{+} y$について$P(y)$が成立するとすると, $x$から始まる無限列は起こり得ない. したがって$P(x)$が成立する. $\rightarrow$がwell foundedであることより, 任意の$z \in A$に対して$P(z)$, すなわち$\rightarrow$の停止性が従う.

 十分性を背理法により示す. 任意の$x \xrightarrow{+} y$について$P(y)$ならば$P(x)$かつ, ある$z \in A$が存在して$P(z)$が成立しないと仮定する. 前半の主張の対偶をとると, 任意の$x \in A$に対して$P(x)$が成立しないならば, ある$y \in A$で$x \xrightarrow{+} y$かつ$P(y)$が成立しないものが存在することになる. この主張を用いて$z$から始まる無限列を構成することができる.
\end{proof}

\begin{rem}
帰納的に定義された(有限)木構造に対して, 自然な順序が存在する.
このときその順序に対して, well foundednessを常に適用できるが, これを断りなく帰納法と呼ぶ.
\end{rem}

%\section{型理論とは}
% 仰々しい?
% 1

\section{ラムダ計算}\label{lambda}
この節ではCoCの基礎となる(型なし)ラムダ計算のいくつかの事実を述べる.

\begin{defn}
 ラムダ項$t$とは, 以下のBNFで定義される木である. $v$は可算濃度の集合$V$の元を意味している.
 \[
 t ::= v \mid \lambda v. t \mid t t
 \]
\end{defn}

BNFでの定義と同値なものが以下である.

\begin{defn}
 ラムダ項の集合$\Lambda$とは, 以下の条件を満たす最小の集合のことをいう.
 \begin{itemize}
  \item $V \subset \Lambda$
  \item 任意の$v \in V$, $M \in \Lambda$について, $\lambda v. M \in \Lambda$
  \item 任意の$M \in \Lambda$, $N \in \Lambda$について, $M N \in \Lambda$
 \end{itemize}
\end{defn}

ただし, ここではラムダ項そのものの定義ではなくラムダ項の集合を定義している. 以下では記述を簡潔にするため, 構文の定義としてBNFでの表記を用いることとする.

ラムダ計算のシステムは計算として機能するための作用を持つ. そのうちの最も本質的なものが$\beta$簡約と呼ばれている.

\begin{defn}
 $\beta$簡約$\rightarrow_{\beta}$とは$\Lambda$の上の$2$項関係であり, 以下の条件を満たす最小の関係のことをいう.
 \begin{itemize}
  \item 任意の$v \in V$, $M, N \in \Lambda$について, $(\lambda v. M) N \rightarrow_\beta M[N/v]$
  \item 任意の$v \in V$, $N_1, N_2 \in \Lambda$について, $N_1 \rightarrow_\beta N_2$ならば$(\lambda v. N_1) \rightarrow_\beta (\lambda v. N_2)$
  \item 任意の$M, N_1, N_2 \in \Lambda$について, $N_1 \rightarrow_\beta N_2$ならば$M N_1 \rightarrow_\beta M N_2$かつ$N_1 M \rightarrow_\beta N_2 M$
 \end{itemize}
 ただし, ここで$M[N/v]$とは代入と呼ばれる操作を表している. 代入とはラムダ項$M \in \Lambda$の中に表れる$v \in V$をすべてラムダ項$N \in \Lambda$に置きかえるということである.
\end{defn}

ここで述べた代入という操作を正確に記述するために, de Brujin indexとよばれるものを導入する.
集合$V$は変数の集合を表しており, 我々の状況では$V := \mathbb{N}$として問題ないため, 以下ではそのようにする.

また, ラムダ項の定義を修正し以下のようにする.

\begin{defn}
 \[
 t ::= v \mid \lambda. t \mid t t
 \]
\end{defn}

\begin{defn}[de Brujin index]
 写像 $s \colon \Lambda \times \mathbb{N} \times \mathbb{N} \rightarrow \Lambda$を任意のラムダ項$M$, 自然数$n, c$に対して, 以下のように帰納的に定義する.

\[
  s (M, n, c) := \begin{cases}
    M & (M \in V \text{かつ} M < c) \\
    M + n & (M \in V \text{かつ} M \geq c) \\
    \lambda. s (N, n, c + 1) & (M = \lambda. N) \\
    s (N_1, n, c) s (N_2, n, c) & (M = N_1 N_2)
  \end{cases}
\]
 この写像$s$を用いて, ラムダ項$M, N \in \Lambda$, 変数$v \in V$に対する代入を以下のように帰納的に定義する.

\[
 M[N/v] := \begin{cases}
    N & (M = v) \\
    M - 1 & (M \in V \text{かつ} v < M) \\
    M & (M \in V \text{かつ} v \geq M) \\
    \lambda. M' [s (N, 1, 0)/(v + 1)] & (M = \lambda. M') \\
    N_1[N/v] N_2[N/v] & (M = N_1 N_2)
  \end{cases}
\]
\end{defn}

ここで述べている$s$という写像はあらわれた$\lambda$の分, 参照するべき数字を増やすという働きをしている.

$\beta$簡約の定義も修正する.

\begin{defn}
 $\beta$簡約$\rightarrow_{\beta}$とは$\Lambda$の上の$2$項関係であり, 以下の条件を満たす最小の関係のことをいう.
 \begin{itemize}
  \item 任意の$M, N \in \Lambda$について, $(\lambda. M) N \rightarrow_\beta M[N/0]$
  \item 任意の$N_1, N_2 \in \Lambda$について, $N_1 \rightarrow_\beta N_2$ならば$(\lambda. N_1) \rightarrow_\beta (\lambda. N_2)$
  \item 任意の$M, N_1, N_2 \in \Lambda$について, $N_1 \rightarrow_\beta N_2$ならば$M N_1 \rightarrow_\beta M N_2$かつ$N_1 M \rightarrow_\beta N_2 M$
 \end{itemize}
\end{defn}

de Brujin indexについて注意すべき性質がある.

\begin{lem}
 任意の$t, r \in \Lambda$に対して, $s (t, 1, 0)[r/0] = t$.
\end{lem}
\begin{proof}
 帰納法による.
\end{proof}

\begin{ex}[$\K$ コンビネータ]
 $V$を文字列の集合とする. このとき $x, y \in V$, $z, w \in \Lambda$に対して以下の様な例が考えられる.
 \[
 (\lambda x. \lambda y. x) z w \rightarrow_{\beta} (\lambda y. z) w \rightarrow_{\beta} z
 \]
 これをde Brujin indexで表わすと, $z, w \in \Lambda$に対して以下のようになる.
 \[
 (\lambda. \lambda. 1) z w \rightarrow_{\beta} (\lambda. 1)[z/0] w = (\lambda. 1[s (z, 1, 0)/1]) w \rightarrow_{\beta} 1[s (z, 1, 0)/1][w/0] = s (z, 1, 0)[w/0] = z
 \]
ここでの$\lambda. \lambda. 1$を$\K$コンビネータという.
\end{ex}

ラムダ計算の基本的な性質として合流性がある.

\begin{thm}[Church Rosserの定理]\label{CR}
 $\beta$簡約$\rightarrow_{\beta}$は合流性を持つ.
\end{thm}

以下では定理\ref{CR}を示すために必要な準備を行う. まずparallel reductionと呼ばれる2項関係を定義する.

\begin{defn}
 parallel reduction$\rightarrow_{p}$とは$\Lambda$の上の$2$項関係であり, 以下の条件を満たす最小の関係のことをいう.
 \begin{description}
  \item[P1] 任意の$x, y \in V$について, $x = y$ならば$x \rightarrow_{p} y$
  \item[P2] 任意の$t, s \in \Lambda$について, $t \rightarrow_{p} s$ならば$\lambda. t \rightarrow_{p} \lambda. s$
  \item[P3] 任意の$t_1, t_2, s_1, s_2 \in \Lambda$について,
        $t_1 \rightarrow_{p} s_1$かつ$t_2 \rightarrow_{p} s_2$ならば$t_1 t_2 \rightarrow_{p} s_1 s_2$
  \item[P4] 任意の$t_1, t_2, s_1, s_2 \in \Lambda$について,
        $t_1 \rightarrow_{p} s_1$かつ$t_2 \rightarrow_{p} s_2$ならば$(\lambda. t_1) t_2 \rightarrow_{p} s_1[s_2/0]$
 \end{description}
\end{defn}

\begin{lem}\label{spp}
 代入はparallel reduction$\rightarrow_{p}$を保つ. すなわち$t_1, t_2, s_1, s_2 \in \Lambda$, $u \in V$に対して, $t_1 \rightarrow_{p} t_2$かつ$s_1 \rightarrow_{p} s_2$ならば$s_1[t_1/u] \rightarrow_{p} s_2[t_2/u]$.
\end{lem}

\begin{proof}
 $\rightarrow_{p}$の定義による帰納法を用いる. P4%TODO: fix
のみが非自明なので, その場合のみを示す.
 すなわち$p, q, t_1, t_2, s_1, s_2 \in \Lambda$に対して,
$p \rightarrow_{p} q$, $t_1 \rightarrow_{p} s_1$かつ $t_2 \rightarrow_{p} s_2$ならば$((\lambda. t_1) t_2) [p / u] \rightarrow_{p} (s_1 [s_2 / 0] [q / u])$を示す.

 代入を交換すると, 以下のような等式が成立する
 \[
 s_1 [s_2 / 0][q / u] = s_1 [s(q, 1, 0) / (u + 1)][s_2 [q / u] / 0]
 \]
 ことに注意する. 上の等式により, $t_1$に対しての帰納法の仮定を適用することができて, 主張が成立する.
\end{proof}

parallel reductionと$\beta$簡約の関係は以下のようになる.

\begin{lem}
 $\rightarrow_{\beta} \subset \rightarrow_{p} \subset \overset{*}{\rightarrow_{\beta}}$
\end{lem}

\begin{proof}
 前半は項のサイズによる帰納法を用いて示される. 後半は$\rightarrow_{p}$の定義による帰納法を用いて示される.
\end{proof}

\begin{cor}
 $\overset{*}{\rightarrow_{p}} = \overset{*}{\rightarrow_{\beta}}$
\end{cor}

上記の系と推移反射閉包を取る操作が合流性を保つことに注意すると, 定理\ref{CR}の言い換えが得られる.

\begin{thm}[Church Rosserの定理]\label{CR'}
 $\rightarrow_{p}$は合流性を持つ.
\end{thm}

\begin{proof}
 証明は\cite{高橋正子1991計算論}の71ページに従った.
任意の$M \in \Lambda$に対して, ある$N_M \in \Lambda$が存在し, 任意の$L \in \Lambda$に対して, $M \rightarrow_p L$ならば$L \rightarrow_p N_M$という主張を証明する.

$M \in \Lambda$を固定する. この$M$に対する帰納法を用いて主張を示す.

$M \in V$の場合, $N_M := M$とすれば, 任意の$L \in \Lambda$に対して, P1でのみ$M \rightarrow_p L$が与えられるため, このとき$L = M$. すなわち, $L \rightarrow_p N_M$.

$M = \lambda. M_0$となる$M_0 \in \Lambda$が存在する場合は, $N_M := \lambda. N_{M_0}$とするとよい.
実際, 任意の$L \in \Lambda$に対して, $M \rightarrow_p L$と仮定する.
このとき, ある$L_0 \in \Lambda$が存在して, $L = \lambda. L_0$, $M_0 \rightarrow_p L_0$となる.
なぜならば, $M \rightarrow_p L$となるときには, P2で$M \rightarrow_p L$が構成されることしか有り得ないためである.
すると帰納法の仮定より$L_0 \rightarrow_p N_{M_0}$, 再びP2により$L \rightarrow_p N_M$.

$M = (\lambda. M_0) M_1$となる$M_0, M_1 \in \Lambda$が存在する場合, $N_M := N_{M_0}[N_{M_1}/0]$とするとよい. 実際, 任意の$L \in \Lambda$に対して, $M \rightarrow_p L$と仮定する. このとき, $M \rightarrow_p L$の与えられ方はP3あるいはP4のいずれかとなる.

 P3のとき$L = (\lambda. L_0) L_1$となる$L_0, L_1 \in \Lambda$が存在し, $M_0 \rightarrow_p L_0$かつ$M_1 \rightarrow_p L_1$でなければならない. 帰納法の仮定により$L_0 \rightarrow_p N_{M_0}$かつ$L_1 \rightarrow_p N_{M_1}$となっているため, P4により$(\lambda. L_0) L_1 \rightarrow_p N_{M_0} [N_{M_1}/0]$が得られる.

 P4のとき$L = L_0 [L_1/0]$となる$L_0, L_1 \in \Lambda$が存在し, $M_0 \rightarrow_p L_0$かつ$M_1 \rightarrow_p L_1$でなければならない. 帰納法の仮定により$L_0 \rightarrow_p N_{M_0}$かつ$L_1 \rightarrow_p N_{M_1}$となっているため, 補題\ref{spp}より$L_0 [L_1/0] \rightarrow_p N_{M_0} [N_{M_1}/0]$が得られる.

最後に$M = M_0 M_1$となる$M_0, M_1 \in \Lambda$が存在する場合, $N_M := N_{M_0} N_{M_1}$とするとよい. これも自明である.
\end{proof}

\section{Calculus of Construction}
この節ではCoCの定義および停止性の証明を与える. 型なしラムダ計算における議論とは平行していることに注意されたい.
型なしの場合におけるラムダ項に対応するものとしてpseudotermと呼ばれるものを定義する.

\begin{defn}
 pseudoterm $p$とは, 以下のBNFで定義される木である. $v$は自然数を意味している.
 \[
 p ::= v \mid \lambda p. p \mid \Pi p. p \mid p p \mid \star \mid \square
 \]
 また, $P$をpseudotermの集合とする.
\end{defn}

\begin{defn}
 $\beta$簡約$\rightarrow_{\beta}$とは$P$の上の$2$項関係であり, 以下の条件を満たす最小の関係のことをいう.
 \begin{itemize}
  \item 任意の$M, T, N \in P$について, $(\lambda T. M) N \rightarrow_\beta M[N/0]$
  \item 任意の$N_1, N_2, M \in P$について, $N_1 \rightarrow_\beta N_2$ならば$\lambda M. N_1 \rightarrow_\beta \lambda M. N_2$かつ$\lambda N_1. M \rightarrow_\beta \lambda N_2. M$
  \item 任意の$N_1, N_2, M \in P$について, $N_1 \rightarrow_\beta N_2$ならば$\Pi M. N_1 \rightarrow_\beta \Pi M. N_2$かつ$\Pi N_1. M \rightarrow_\beta \Pi N_2. M$
  \item 任意の$N_1, N_2, M \in P$について, $N_1 \rightarrow_\beta N_2$ならば$M N_1 \rightarrow_\beta M N_2$かつ$N_1 M \rightarrow_\beta N_2 M$
 \end{itemize}
\end{defn}

 ただし, ここでもあいまいさを回避するためにde Brujin indexによって代入を定義する.

\begin{defn}[de Brujin index]
 写像 $s \colon P \times \mathbb{N} \times \mathbb{N} \rightarrow P$を任意のpseudoterm $M$, 自然数$n, c$に対して, 以下のように帰納的に定義する.

\[
  s (M, n, c) := \begin{cases}
    M & (M \in \mathbb{N} \text{かつ} M < c \text{ 又は } M = \star, \square) \\
    M + n & (M \in \mathbb{N} \text{かつ} M \geq c) \\
    \lambda s (N_1, n, c). s (N_2, n, c + 1) & (M = \lambda N_1. N_2) \\
    \Pi s (N_1, n, c). s (N_2, n, c + 1) & (M = \Pi N_1. N_2) \\
    s (N_1, n, c) s (N_2, n, c) & (M = N_1 N_2)
  \end{cases}
\]
 pseudoterm $M, N \in P$, 変数$v \in \mathbb{N}$に対する代入を以下のように帰納的に定義する.

\[
 M[N/v] := \begin{cases}
    N & (M = v) \\
    M - 1 & (M \in \mathbb{N} \text{かつ} v < M) \\
    M & (M \in \mathbb{N} \text{かつ} v \geq M \text{ 又は } M = \star, \square) \\
    \lambda M_1 [s (N, 1, 0)/v]. M_2 [s (N, 1, 0)/(v + 1)] & (M = \lambda M_1. M_2) \\
    \Pi M_1 [s (N, 1, 0)/v]. M_2 [s (N, 1, 0)/(v + 1)] & (M = \Pi M_1. M_2) \\
    N_1[N/v] N_2[N/v] & (M = N_1 N_2)
  \end{cases}
\]
\end{defn}

\ref{lambda}章とまったく同様の議論をおこなうことにより, CoCに対するChurch Rosserの定理を得ることができる.

\begin{thm}[Church Rosserの定理]
 $\beta$簡約$\rightarrow_{\beta}$は合流性を持つ.
\end{thm}

型づけ規則とよばれる自然演繹のシステムが存在し, それも含めての計算体系としてCoCは定義される.

\begin{defn}
 文脈$\Gamma$とは, 以下のBNFで定義される木である. $p$はpseudotermを意味する.
 \[
 \Gamma ::= \Gamma, p \mid
 \]
 % ただし, ここで述べている$v : p$とは型づけと呼ばれ, 型づけ規則とよばれるいくつかの公理から生成される木が存在することを意味している. 型づけ規則とは, 以下のように定義される.
 さらに, 型づけ規則とよばれるいくつかの公理から生成される木が定義される.

 pseudoterm $p, q \in P$が文脈$\Gamma$のもとで, $p : q$であるとは以下のいずれかの場合である.
 また, この状況を$\Gamma \vdash p : q$と書きあらわす.
 \begin{description}
  \item[Ax] $p = {\star}, q = {\square}$
  \item[Var] $p = 0$かつ, ある文脈$\Gamma'$が存在して$\Gamma = \Gamma', q$となる. またpseudoterm $t$が存在して$q = s(t, 1, 0)$となり, $\Gamma' \vdash t : \star$であるか$\Gamma' \vdash t : \square$となる.
% さらに, $p$は$\Gamma'$に現れるどの変数とも異なっていなければならない.
  \item[Weak] ある文脈$\Gamma'$およびpseudoterm $r$が存在して$\Gamma = \Gamma', r$となり, $\Gamma' \vdash p : q$である. また, $\Gamma' \vdash r : \star$であるか$\Gamma' \vdash r : \square$となる.
  \item[\Pi] あるpseudoterm $r, u$が存在して, $p = \Pi r. u$. かつ, $q = \star$あるいは$q = \square$. また$\Gamma \vdash r : \star$であるか$\Gamma \vdash r : \square$となる. さらに, $\Gamma, r \vdash u : q$が成立する.
  \item[\lambda] あるpseudoterm $r, u, m$が存在して, $p = \lambda r. m$, $q = \Pi r. u$. また, $\Gamma \vdash q : \star$であるか$\Gamma \vdash q : \square$となる. さらに, $\Gamma, r \vdash m : u$が成立する.
  \item[App] あるpseudoterm $n, m, u$が存在して, $p = m n$, $q = u[n/0]$. また, pseudoterm $t$が存在して$\Gamma \vdash m : \Pi t. u$かつ$\Gamma \vdash n : t$.
  \item[Conv] あるpseudoterm $t$が存在して, $t \overset{*}{\leftrightarrow}_\beta q$かつ$\Gamma \vdash p : t$. また$\Gamma \vdash q : \star$であるか$\Gamma \vdash q : \square$となる.
 \end{description}
 これらの定義の仕方は煩雑であるため, いくつかの規則によって生成される木が型づけとなることを暗黙の内に処理することが習慣となっている. そのような書き方による同値な定義を以下に述べる.
 \begin{description}
  \item[Ax] \[ \frac{}{\vdash {\star} {\colon} {\square}} \]
  \item[Var] \[ \frac{\Gamma \vdash t {\colon} {\star} \text{ or } {\square}}{\Gamma, t \vdash 0 {\colon} s(t, 1, 0)} \]
  \item[Weak] \[ \frac{\Gamma \vdash t {\colon} {\star} \text{ or } \square \quad \Gamma \vdash m {\colon} u}{\Gamma, t \vdash m {\colon} u} \]
  \item[\Pi] \[ \frac{\Gamma \vdash r {\colon} {\star} \text{ or } {\square} \quad \Gamma, r \vdash u {\colon} s}{\Gamma \vdash \Pi r. u {\colon} s}
             \quad
             s = {\star} \text{ or } {\square} \]
  \item[\lambda] \[ \frac{\Gamma \vdash \Pi r. u {\colon} {\star} \text{ or } {\square} \quad \Gamma, r \vdash m : u}{\Gamma \vdash \lambda r. m {\colon} \Pi r. u} \]
  \item[App] \[ \frac{\Gamma \vdash m : \Pi t. u \quad \Gamma \vdash n : t}{\Gamma \vdash m n {\colon} u[n/0]} \]
  \item[Conv] \[\frac{\Gamma \vdash q {\colon} {\star} \text{ or } {\square} \quad \Gamma \vdash p {\colon} t \quad t \overset{*}{\leftrightarrow}_\beta q}{\Gamma \vdash p {\colon} q} \]
 \end{description}
 ここで現れる横に長い棒は含意を意味している. またpseudoterm $p, q$に対して, ある文脈$\Gamma$が存在して, $\Gamma \vdash p : q$となるとき, $\Gamma \vdash$を省略して$p : q$と書くことがある.
\end{defn}

\begin{rem}
 規則$\Pi$は四通り存在する.
\end{rem}

CoCにおいては, $\Pi$には複数の役割がある.
\begin{itemize}
 \item 計算論的な側面からは, $\Pi$は関数あるいは写像の型
 \item 命題論理学的な側面からは, $\Pi$は含意
 \item 述語論理学的な側面からは, $\Pi$は述語
\end{itemize}
をそれぞれ意味している. $\Pi$の柔軟性により, CoCは現代数学に現われるほとんどの主張をいいあらわすことができる.

また, Curry Howard対応というものが広く知られており, $\Gamma \vdash p : q$であるときに, $q$を命題の主張, $p$をその証明とみなすことが可能である. CoCの本来の役割は証明を記述し, 型づけによりその整合性を確かめることにあった.

% \begin{rem}
%  上記の定義では文脈と型づけ規則が同時に定義されていることに注意されたい. したがって, 上記の定義は帰納的な定義になっており循環していない.
% \end{rem}

難しくない事実として, Subject Reductionと呼ばれるものがある.

\begin{thm}[Subject Reduction]
 文脈$\Gamma$, pseudoterm $A, B, C \in P$に対して, $\Gamma \vdash A \colon C$, $A \rightarrow_\beta B$のとき$\Gamma \vdash B \colon C$.
 % wrong statement
 % また$\Gamma \vdash C \colon A$, $A \rightarrow_\beta B$のとき$\Gamma \vdash C \colon B$.
\end{thm}
\begin{proof}
 型づけに対する帰納法を用いる.
 \begin{description}
  \item[Ax, Var] $\beta$簡約が存在しない.
  \item[Weak, Conv] 帰納法の仮定より直ちに従う.
  \item[\Pi] $\beta$簡約$A (= \Pi r. u) \rightarrow_\beta B$のうち, $B = \Pi r'. u, r \rightarrow_\beta r'$となる$r' \in P$がある場合が非自明である. この場合は規則$\Pi$, Weakおよび帰納法の仮定を用いれば主張が示せる.
  \item[\lambda] $\beta$簡約$A (= \lambda r. m) \rightarrow_\beta B$のうち, $B = \lambda r'. m, r \rightarrow_\beta r'$となる$r' \in P$がある場合が非自明である. この場合は規則Conv, $\lambda$, $\Pi$, Weakおよび帰納法の仮定を用いれば主張が示せる.
  \item[App] $\beta$簡約$A (= (\lambda t. m) n) \rightarrow_\beta B$のうち, $B = m[n/0]$となる$t, m \in P$がある場合が非自明である. この場合は規則$\lambda$, Weak, 帰納法の仮定および代入が型づけを保存することに注意すれば示せる.
 \end{description}
\end{proof}

\begin{ex}[恒等射]
 単純ではあるが普遍的なものとして恒等射があるが, CoCには恒等射を表現するのに十分な能力がある. (これは型理論にとっては自明ではない.)

 pseudoterm $p$を$p \colon {\square}$となる様なものとするとき, この上の恒等射としてふさわしい項は$\lambda p. 0 \colon \Pi p. s(p, 1, 0)$となる. 実際に$q \colon p$となる$q$をとると, 規則Appにより$(\lambda p. 0)q \colon s(p, 1, 0)[q/0] \rightarrow_\beta 0[q/0] \colon p = q \colon p$となることが確認される.

 また例えば$p = \star$に対して, $\lambda p. 0 \colon \Pi p. s(p, 1, 0)$が型づけ可能であることは以下の様に示される.
\begin{prooftree}
\AxiomC{$\vdash \star \colon \square$}
\AxiomC{$\vdash \star \colon \square$}
\AxiomC{$\vdash s(p, 1, 0) = \star \colon \square$}
\RightLabel{Weak}
\BinaryInfC{$p \vdash s(p, 1, 0) \colon \square$}
\RightLabel{$\Pi$}
\BinaryInfC{$\vdash \Pi p. s(p, 1, 0) \colon \square$}
\AxiomC{$\vdash \star \colon \square$}
\RightLabel{Var}
\UnaryInfC{$p \vdash 0 \colon s(p, 1, 0)$}
\RightLabel{$\lambda$}
\BinaryInfC{$\vdash \lambda p.0 \colon \Pi p. s(p, 1, 0)$}
\end{prooftree}
このような図式を証明木と言う.
\end{ex}

型つきの計算規則のもとでは, 型がつく項のみが考える対象となる. 実際, 型づけ可能な$P$上の$\beta$簡約に対しては停止性が成立する. 以下では停止性の証明に必要な準備を行っていく. 証明は\cite{geuvers1994short}, \cite{girard1989proofs}に従った.

簡単な帰納法により示される事実ではあるが, 重要なこととして以下の補題がある.

\begin{lem}[Classification]\label{clsfy}
 文脈$\Gamma$, pseudoterm $A, B \in P$に対して, $\Gamma \vdash A \colon B$となるのは以下の場合のいずれかに限る. また, それぞれの条件は重複しない.
 \begin{description}
  \item[Kind] $B = \square$
  \item[Constr] $\Gamma \vdash B {\colon} {\square}$
  \item[Obj] $\Gamma \vdash B {\colon} {\star}$
 \end{description}
\end{lem}
\begin{proof}
 型づけに対する帰納法を用いる. また, 証明を簡潔にするため, Convによる型づけの導出の不定性は無視する. 実際Subject Reductionにより, 分類を保ったまま導出からConvを消去することは可能である.
 \begin{description}
  \item[Ax] 自明にKindのみが成立する.
  \item[Var] 帰納法により$\square \colon \star$および$\square \colon \square$がおこらないことがわかるため, Kindはあり得ない. 型づけを生成する含意の前提に注目すると, 前提が$\Gamma \vdash t {\colon} {\star}$のとき, Weakを用いれば$\Gamma, t \vdash t {\colon} {\star}$が分かるので結論はObjであり, $\Gamma \vdash t {\colon} {\square}$のときはConstrとなる. 逆に結論に対してObjかつConstrであると仮定するとWeakで分解できて, $\Gamma \vdash t {\colon} {\star}$かつ$\Gamma \vdash t {\colon} {\square}$となるがこれは帰納法の仮定に反する.
  \item[Weak] 前提の二番目$\Gamma \vdash m {\colon} u$の分類が, 結論に一対一に対応することが直ちに分かる.
  \item[\Pi] 分類の一意性のみが非自明である. 前提の二番目$\Gamma, r \vdash u {\colon} s$に対して, Weakで分解できるので, 帰納法の仮定より主張が従う.
  \item[\lambda] 自明である.
  \item[App] 代入が型づけを保つ事実および, 規則$\Pi$が分類を保つことに注意すれば, 帰納法の仮定が反映される.
 \end{description}
\end{proof}

\begin{defn}
補題\ref{clsfy}を踏まえて, pseudotermの集合$P$をいくつかのクラスに分類する.
 \begin{itemize}
  \item $\Kind := \{ A \mid \Gamma \text{が存在し} \Gamma \vdash A \colon {\square}\}$
  \item $\Constr := \{ P \mid \Gamma, A \text{が存在し} \Gamma \vdash P \colon A \text{ かつ } \Gamma \vdash A \colon {\square}\}$
  \item $\Obj := \{ P \mid \Gamma, A \text{が存在し} \Gamma \vdash P \colon A \text{ かつ } \Gamma \vdash A \colon {\star}\}$
 \end{itemize}
 補題\ref{clsfy}でみたようにこれらは互いにdisjointである.

 同様に, disjointではないクラスとして以下を定義する.
 \begin{itemize}
  \item $\Term := \{p \mid \Gamma, t \text {が存在し} \Gamma \vdash t : p \text{または} \Gamma \vdash p : t \}$
  \item $\Type := \{ A \mid \Gamma \text{が存在し} \Gamma \vdash A \colon {\star}\}$
 \end{itemize}

また文脈$\Gamma$に対して, 以下のように定義する.
 \begin{itemize}
  \item $\GKind := \{ A \mid \Gamma \vdash A \colon {\square}\}$
  \item $\GConstr := \{ P \mid A \text{が存在し} \Gamma \vdash P \colon A \text{ かつ } \Gamma \vdash A \colon {\square}\}$
  \item $\GObj := \{ P \mid A \text{が存在し} \Gamma \vdash P \colon A \text{ かつ } \Gamma \vdash A \colon {\star}\}$
  \item $\GTerm := \{p | t \text {が存在し} \Gamma \vdash t : p \text{または} \Gamma \vdash p : t \}$
  \item $\GType := \{ A \mid \Gamma \vdash A \colon {\star}\}$
 \end{itemize}
\end{defn}

以下では$d \in \Lambda$として正規形となるものを一つ固定する. また$\SN := \{ t \in \Lambda \mid t \text{は停止する}\}$とする.

\begin{defn}
 base terms $\mathcal{B}$を以下を満たす最小の集合として定義する.
 \begin{itemize}
  \item $\mathbb{N} \subset \mathcal{B}$かつ$d \in \mathcal{B}$
  \item $m \in \mathcal{B}$かつ$n \in \SN$ならば, $mn \in \mathcal{B}$
 \end{itemize}
\end{defn}

\begin{defn}
 型なしラムダ計算のkey redexを以下を満たし, 最小になるように定義する.
 \begin{itemize}
  \item $m \in \Lambda$がredexであれば, $m$はkey redex.
  \item $m \in \Lambda$がkey redex $n \in \Lambda$を持てば, 任意の$p \in \Lambda$に対して, $m p$もkey redexとして$n$を持つ.
 \end{itemize}
ここで述べたredexとよばれる項は, 簡約がおこる部分木のことを指している. すなわち, $(\lambda. e) e' \quad (e, e' \in \Lambda)$となるような形の項のことを指している.

また, $m$に対するkey redexを$\red_k(m)$と書く.
\end{defn}

\begin{defn}[Saturated Set]\label{ss}
 型なしラムダ項の集合$X \subset \Lambda$がsaturatedであるとは, 以下のすべてを満たすものをいう.
 \begin{itemize}
  \item $X \subset \SN$.
  \item $\mathcal{B} \subset X$.
  \item 任意の$m \in \Lambda$に対して, $\red_k(m) \in X$かつ$m \in \SN$ならば$m \in X$.
 \end{itemize}
 saturatedな集合の集合を$\SAT$と書く.
\end{defn}

\begin{rem}
 Saturated Setは停止性の証明において本質的である.
\end{rem}

\begin{lem}
 $\SAT$は交差と含意で閉じる. すなわち以下を満たす.
 \begin{itemize}
  \item Saturated Set $X, Y$に対して, $X \cap Y$もsaturatedとなる.
  \item Saturated Set $X, Y$に対して, $\{ M \in \Lambda \mid \text{任意の} N \in X \text{に対して}, M N \in Y\}$もsaturatedとなる.
 \end{itemize}
 ここで現れた $\{ M \in \Lambda \mid \text{任意の} N \in X \text{に対して}, M N \in Y\}$を$X \rightarrow Y$とかく.
\end{lem}
\begin{proof}
 前半は自明である.
 後半をみるには定義\ref{ss}の帰納的ないいかえを考えるとよい. すなわち,
 型なしラムダ項の集合$X \subset \Lambda$がsaturatedであるとは, 以下のすべてを満たすものをいう.
 \begin{itemize}
  \item $X \subset \SN$.
  \item $n \in \mathbb{N}, q_1, \ldots, q_n \in \SN, x \in \mathbb{N}$に対して, $x q_1 \ldots q_n \in X$.
  \item $n \in \mathbb{N}, q_1, \ldots, q_n \in \SN$に対して, $d q_1 \ldots q_n \in X$.
  \item $n \in \mathbb{N}, q_1, \ldots, q_n, m, p \in \SN$に対して, $m[p/0]q_1 \ldots q_n \in X$ならば$(\lambda . m)p q_1 \ldots q_n \in X$.
 \end{itemize}
最後のいいかえについては, key redexの定義を考えればすぐにいえる.
さて, $n \in \mathbb{N}, q_1, \ldots, q_n, m, p \in \SN$に対して, $m[p/0]q_1 \ldots q_n \in X \rightarrow Y$とする. このとき, $(\lambda m)p q_1 \ldots q_n \in X \rightarrow Y$を言いたい.
すなわち, 任意の$l \in X$に対して, $(\lambda m)p q_1 \ldots q_n l \in Y$となることを言いたい.
 $Y$はSaturated Setであったので, $m[p/0] q_1 \ldots q_n l \in Y$であればよいが, $m[p/0]q_1 \ldots q_n \in X \rightarrow Y$であったので主張が従う.
\end{proof}

\begin{defn}
 解釈$\mathcal{V} : \Kind \rightarrow \Set$を以下のように帰納的に定義する.
\[
  \mathcal{V} (A) := \begin{cases}
    \SAT & (A \in \Type) \\
    \{ f \mid f : \mathcal{V}(B) \rightarrow \mathcal{V}(C) \} & (A = \Pi B. C, B \in \Kind) \\
    \mathcal{V} (C) & (A = \Pi B. C, B \in \Type)
  \end{cases}
\]
 $\mathcal{V}$による像を集めた集合を$(\SAT)^\star := \bigcup_{A \in \Kind} \mathcal{V}(A)$のように書く.
\end{defn}

\begin{defn}
 文脈の$n + 1$番目を取る操作を以下のように定義する. ただし, $n$は文脈$\Gamma$のサイズを越えないものとする.
\[
  \Gamma (n) := \begin{cases}
    s (\Gamma' (n - 1), 1, 0) & (\Gamma = \Gamma', A  \text{ かつ } n > 0) \\
    s(A, 1, 0) & (\Gamma = \Gamma', A  \text{ かつ } n = 0)
  \end{cases}
\]
ここでの$s$はde Brujin indexを合わせるためにつけている.
\end{defn}

\begin{lem}
 文脈$\Gamma$および, 自然数$n$で$\Gamma$のサイズを越えないものに対して, $\Gamma \vdash n \colon \Gamma (n)$.
\end{lem}
\begin{proof}
 帰納法による.
\end{proof}

\begin{defn}
集合$A$, 写像$\xi : \mathbb{N} \rightarrow A$および$a \in A$に対して,
 \[
   \xi[a](n) := \begin{cases}
    a & (n = 0) \\
    \xi(n - 1) & (n > 0)
  \end{cases}
 \]
とする.
\end{defn}

\begin{defn}
 文脈$\Gamma$に対して写像$\xi : \mathbb{N} \rightarrow (\SAT)^\star$がconstructor valuationであるとは, 自然数$n$で$\Gamma$のサイズを越えないものに対して, $\xi (n) \in \mathcal{V}(\Gamma(n))$となるもののことを言う.
\end{defn}

\begin{defn}
 文脈$\Gamma$とそのconstructor valuation $\xi : \mathbb{N} \rightarrow (\SAT)^\star$に対して, 写像$\iprt{\cdot}{\xi} : \GTerm \setminus \GObj \rightarrow (\SAT)^\star$を以下のように帰納的に定義する.
\[
 \iprt{A}{\xi} := \begin{cases}
    \SN & (A = \star \text{ または } \square) \\
    \xi (A) & (A \in \mathbb{N}) \\
    \iprt{p}{\xi} (\iprt{q}{\xi}) & (A = p q, q \in \Constr) \\
    \iprt{p}{\xi} & (A = p q, q \in \Obj) \\
    \mathcal{V} (t) \ni a \mapsto \iprt{p}{\xi[a]} & (A = \lambda t. p, t \in \Kind) \\
    \iprt{p}{\xi[d]} & (A = \lambda t. p, t \in \Type) \\
    \iprt{t}{\xi} \rightarrow \iprt{p}{\xi[d]} & (A = \Pi t. p, t \in \Type) \\
    \iprt{t}{\xi} \rightarrow \cap_{a \in \mathcal{V}(t)} \iprt{p}{\xi[a]} & (A = \Pi t. p, t \in \Kind)
  \end{cases}
\]
\end{defn}
\begin{rem}
 上記の定義は写像としてうまく定義されている. 実際型づけの規則から, 上記のような場合しか起こり得ないことを示すことができる.
\end{rem}
\begin{lem}\label{betap}
 写像$\iprt{\cdot}{\xi}$は代入と$\beta$簡約に対して整合的である. すなわち以下が成立する.
 \begin{itemize}
  \item pseudoterm $p, q \in P$に対して$p [q/0] \in \GTerm \setminus \GObj$とする.
        このとき$i \in \mathbb{N}$, $a_1, \ldots, a_i \in (\SAT)^\star$に対して,
        \[
        \iprt{p [s (q, i, 0)/i]}{\xi[a_i]\ldots[a_1]} = \begin{cases}
        \iprt{p}{\xi[d][a_i]\ldots[a_1]} & (q \in \Obj) \\
        \iprt{p}{\xi[\iprt{q}{\xi}][a_i]\ldots[a_1]} & (\text{その他})
        \end{cases}
        \]
  \item $p, q \in \GTerm \setminus \GObj$に対して$p \overset{*}{\leftrightarrow}_\beta q$ならば, $\iprt{p}{\xi} = \iprt{q}{\xi}$.
 \end{itemize}
\end{lem}
\begin{proof}
 後半は前半から直ちに従う. 前半を$p$に対する帰納法により示す.
 \begin{itemize}
  \item $p = i$のとき$q \notin \Obj$なので,
        \[
        \iprt{p [s (q, i, 0)/i]}{\xi[a_i]\ldots[a_1]} = \iprt{s (q, i, 0)}{\xi[a_i]\ldots[a_1]} = \iprt{q}{\xi} = \iprt{p}{\xi[\iprt{q}{\xi}][a_i]\ldots[a_1]}
        \]
  \item $p \neq i$, $p = p_1 p_2$となるときは明らか.
  \item $p = \lambda t. p_0$, $t \in \Kind$, $q \notin \Obj$のとき
        \begin{align*}
        \iprt{p [s (q, i, 0)/i]}{\xi[a_i]\ldots[a_1]} &= \iprt{(\lambda t. p_0) [s (q, i, 0)/i]}{\xi[a_i]\ldots[a_1]} \\
         &= \iprt{\lambda t[s (q, i+1, 0)/i]. p_0[s (q, i+1, 0)/(i+1)]}{\xi[a_i]\ldots[a_1]} \\
         %t[s (q, i+1, 0)/i] は Kind (代入が型づけを保存することから)
         &= a_0 \mapsto \iprt{p_0[s (q, i+1, 0)/(i+1)]}{\xi[a_i]\ldots[a_1][a_0]} \\
         % \mathcal{V} (t[s (q, i+1, 0)/i]) = \mathcal{V} (t)
         &= a_0 \mapsto \iprt{p_0}{\xi[\iprt{q}{\xi}][a_i]\ldots[a_1][a_0]} \\
         &= \iprt{p}{\xi[\iprt{q}{\xi}][a_i]\ldots[a_1]}
        \end{align*}
        となり問題ない.
  \item その他の場合も上記と同様に従う.
 \end{itemize}
\end{proof}

\begin{defn}
 文脈$\Gamma$とそのconstructor valuation $\xi : \mathbb{N} \rightarrow (\SAT)^\star$に対して, 写像$\rho : \mathbb{N} \rightarrow \Lambda$がobject valuationであるとは, 自然数$n$で$\Gamma$のサイズを越えないものに対して, $\rho (n) \in \iprt{\Gamma(n)}{\xi}$となるもののことを言う.
\end{defn}

\begin{defn}
 文脈$\Gamma$とそのconstructor valuation $\xi : \mathbb{N} \rightarrow (\SAT)^\star$, object valuation $\rho : \mathbb{N} \rightarrow \Lambda$に対して, 写像$\iprt{\cdot}{\rho} : \GTerm \setminus \{\square\} \rightarrow \Lambda$を以下のように帰納的に定義する.
\[
 \iprt{A}{\rho} := \begin{cases}
    d & (A = \star) \\
    \rho (A) & (A \in \mathbb{N}) \\
    \iprt{p}{\rho} \iprt{q}{\rho} & (A = p q) \\
    \K (\lambda . \iprt{p}{\rho[0]}) \iprt{t}{\rho} & (A = \lambda t. p) \\
    d \iprt{t}{\rho} (\lambda . \iprt{p}{\rho[0]}) & (A = \Pi t. p)
  \end{cases}
\]
\end{defn}

いままで述べた定義は, CoCのモデルの解釈を与えている. 以下に述べる定理は数理論理学においては健全性定理と呼ばれるものである.

\begin{thm}\label{snd1}
 文脈$\Gamma$, pseudoterm $A \in P$, $B \in P \setminus \{\square\}$に対して$\Gamma \vdash A \colon B$となるとき,
 任意のconstructor valuation $\xi : \mathbb{N} \rightarrow (\SAT)^\star$に対して, $\iprt{A}{\xi} \in \mathcal{V}(B)$.
\end{thm}
\begin{proof}
 帰納法による.
\end{proof}

\begin{thm}\label{snd2}
 文脈$\Gamma$, pseudoterm $A, B \in P$に対して, $\Gamma \vdash A \colon B$となるとき,
 任意のconstructor valuation $\xi : \mathbb{N} \rightarrow (\SAT)^\star$, object valuation $\rho : \mathbb{N} \rightarrow \Lambda$に対して, $\iprt{A}{\rho} \in \iprt{B}{\xi}$.
\end{thm}
\begin{proof}
 $A$に対する帰納法を行う.
 \begin{itemize}
  \item $A \in \mathbb{N}$のとき, 規則Convによる不定性から$B \overset{*}{\leftrightarrow}_\beta \Gamma(A)$, $\iprt{A}{\rho} = \rho (A) \in \iprt{\Gamma(A)}{\xi}$.
        また, 補題\ref{betap}より $\iprt{\Gamma(A)}{\xi} = \iprt{B}{\xi}$.
  \item $A = \lambda p. q$のとき規則$\lambda$, Convより, ある$r \in P$が存在して$\Gamma, p \vdash q \colon r$かつ$\Pi p. r \overset{*}{\leftrightarrow}_\beta B$. このとき, さらに以下の二つに場合分けされる.
 \begin{itemize}
  \item $p \in \Type$のとき, 帰納法の仮定より $\iprt{p}{\rho} \in \iprt{\star}{\xi} = \SN$, $\lambda . \iprt{q}{\rho[0]} \in \iprt{p}{\xi} \rightarrow \iprt{r}{\xi[d]} = \iprt{\Pi p. r}{\xi} = \iprt{B}{\xi}$となる.
        また, 定理\ref{snd1}およびSaturated Setの定義に注意すると$\iprt{A}{\rho} = \iprt{\lambda p. q}{\rho} = \K (\lambda . \iprt{q}{\rho[0]}) \iprt{p}{\rho} \overset{2}{\rightarrow}_\beta \lambda . \iprt{q}{\rho[0]}$であることより, $\iprt{A}{\rho} \in \iprt{B}{\xi}$.
  \item $p \in \Kind$のとき, 帰納法の仮定より $\iprt{p}{\rho} \in \iprt{\square}{\xi} = \SN$, $\lambda . \iprt{q}{\rho[0]} \in \iprt{p}{\xi} \rightarrow \cap_{a \in \mathcal{V}(p)} \iprt{r}{\xi[a]} = \iprt{\Pi p. r}{\xi} = \iprt{B}{\xi}$となる.
        上記の場合と同様に, $\iprt{A}{\rho} \in \iprt{B}{\xi}$.
 \end{itemize}
  \item $A = p q$のとき規則App, Convより, ある$r, t \in P$が存在して$\Gamma \vdash p \colon \Pi t. r$, $\Gamma \vdash q \colon t$, $r[q/0] \overset{*}{\leftrightarrow}_\beta B$. このとき, さらに以下の二つに場合分けされる.
 \begin{itemize}
  \item $q \in \Obj$のとき, 帰納法の仮定より $\iprt{p}{\rho} \in \iprt{\Pi t. r}{\xi} = \iprt{t}{\xi} \rightarrow \iprt{r}{\xi[d]}$, $\iprt{q}{\rho} \in \iprt{t}{\xi}$となる. $\iprt{r[q/0]}{\xi} = \iprt{r}{\xi[d]}$に注意すると, $\iprt{A}{\rho} \in \iprt{B}{\xi}$が分かる.
  \item $q \in \Kind$のとき, 帰納法の仮定より $\iprt{p}{\rho} \in \iprt{\Pi t. r}{\xi} = \iprt{t}{\xi} \rightarrow \cap_{a \in \mathcal{V}(t)} \iprt{r}{\xi[a]}$, $\iprt{q}{\rho} \in \iprt{t}{\xi}$となる. $\iprt{r[q/0]}{\xi} = \iprt{r}{\xi[\iprt{q}{\xi}]}$に注意すると, $\iprt{A}{\rho} \in \iprt{B}{\xi}$が分かる.
 \end{itemize}
  \item $A = \Pi p. q$のとき規則$\Pi$, Convより, ある$s \in \{ \star, \square \}$が存在して$\Gamma, p \vdash q \colon s$, $s \overset{*}{\leftrightarrow}_\beta B$. 帰納法の仮定より $\iprt{p}{\rho} \in \SN$, $\lambda. \iprt{q}{\rho[0]} \in \SN$となるため, $\iprt{B}{\xi} = \SN \ni d \iprt{p}{\rho} (\lambda. \iprt{q}{\rho[0]}) = \iprt{\Pi p. q}{\rho}$.
 \end{itemize}
\end{proof}

canonicalなvaluationを考えることで, 停止性を持つCoCのモデルを得ることができる.

\begin{thm}
 型づけ可能な$P$上の$\beta$簡約$\rightarrow_{\beta}|_{\Term}$は停止性を持つ.
\end{thm}
\begin{proof}
 文脈$\Gamma$を固定する.
 $\GTerm = \{M \mid N \text{が存在し} \Gamma \vdash M \colon N\} \cup \{\square\}$となることに注意する.
 $M \in \GTerm$に対して$M = \square$のときはいうべきことはない. $N$が存在し$\Gamma \vdash M \colon N$となるときを示す.
 $A \in \Kind$に対して$\mathcal{V}(A)$のcanonicalな要素$c^A$を以下のように定義する.
 \[
  c^A := \begin{cases}
    \SN & (A = \star) \\
    \mathcal{V} (t) \ni a \mapsto c^p & (A = \lambda t. p, t \in \Kind) \\
    c^p & (A = \lambda t. p, t \in \Type)
  \end{cases}
 \]
 この$c$を用いて, $\Gamma$に対するconstructor valuation $\xi : \mathbb{N} \rightarrow (\SAT)^\star$を
 \[
  \xi(n) := \begin{cases}
    c^{\Gamma(n)} & (n \text{が} \Gamma \text{のサイズを越えないとき}) \\
    \SN & (その他)
  \end{cases}
 \]
 と定義する. さらに $\Gamma, \xi$に対するobject valuation $\rho : \mathbb{N} \rightarrow \Lambda$を$\rho (n) := n$と定義する.
 このとき, 実際に$\rho$がobject valuationになっていること, すなわち$n$が$\Gamma$のサイズを越えないとき$\rho(n) \in \iprt{\Gamma(n)}{\xi}$となることが, 帰納法により示される.
 定理\ref{snd2}によってこのような$\xi, \rho$に対して$\iprt{M}{\rho} \in \iprt{N}{\xi}$となるが, $\iprt{N}{\xi} \in \SAT$であることが帰納法により確かめられるため$\iprt{M}{\rho} \in \SN$となる. $\iprt{M}{\rho}$が停止することと$M$が停止することの同値性により, $M$は停止することが分かる.
\end{proof}

%\section{論理体系としてのCoC}
% SN と CR -> type jugdement が decidable.
% domain のなかで証明列をながめると?
% CoCでないと扱えないようなStatementの例とは? : Proposition の合成?
% 3

% \section{謝辞}

\bibliography{bib}
\bibliographystyle{junsrt}

\appendix
\section{Code}

\scriptsize
\begin{quote}
\begin{verbatim}
From mathcomp Require Import ssreflect.all_ssreflect.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section Generalities.
Variables T U : eqType.

Fixpoint tcn (r : T -> T -> Prop) n (a b : T) :=
  match n with
  | 0 => a = b
  | 1 => r a b
  | S n' => exists c, tcn r n' a c /\ r c b
  end.

Definition tc r a b := exists n, @tcn r n a b.

Lemma ltn_wf : well_founded (fun x y => x < y).
Proof.
  elim => [//|? IHn]; constructor => y.
  rewrite ltnS leq_eqVlt => /orP [/eqP -> //|].
  by case: IHn => H /H.
Qed.

Lemma tcnS n f a b :
  tcn f n.+1 a b <-> exists c, tcn f n a c /\ f c b.
Proof.
  split; case: n => //.
  by exists a.
  by case=> ? /= [] <-.
Qed.

Lemma tcSn n f a b :
  tcn f n.+1 a b <-> exists c, f a c /\ tcn f n c b.
Proof.
  split.
  elim: (ltn_wf n) a b => {n} n _ IH /= a b.
  case: n IH => // [/= _ ?|n IH].
   by exists b.
  case.
  move=> x [] H y.
  case: (IH n _ _ _ H) => // z [] w H1 {IH}.
  exists z; split => //.
  case: n H1 H => [e|n].
   move: e y w => <- //.
  move=> H0 H1.
  by exists x; split.
  elim: (ltn_wf n) a b => {n} n _ IH /= a b.
  case: n IH => [_ [] ? [] ? <- //|n IH [] c [] ?].
  rewrite /=.
  case: n IH => //.
   move=> *; by exists c.
  move=> n IH [] x [] H b0.
  exists x; split => //.
  apply: (IH n.+1 _ a x) => //.
  by exists c.
Qed.

Lemma tc_refl f x : @tc f x x.
Proof. by exists 0. Qed.

Lemma tc_trans f p q r :
  tc f p q -> tc f q r -> tc f p r.
Proof.
  move=> H1.
  case=> m H2.
  elim: (ltn_wf m) p q r H1 H2 => {m} m _ IH p q r H1 H2.
  case: m H2 IH => /= [<- _ //|m H2 IH].
  case: m H2 IH => //.
   move=> ? IH.
   case: H1 => n H1.
   exists n.+1.
    case: n H1 => /= [-> //|n H1].
    exists q; split => //.
  move=> n H IH.
  case: H => c [] H ?.
  apply: (IH 1) => //.
  apply: (_ : tc f p c).
  apply: (IH n.+1) => //.
  apply H1.
  apply H.
  by [].
Qed.

Lemma tcE f a b :
  tc f a b <-> exists c, tc f a c /\ tc f c b.
Proof.
  split => [?|[] x [] /tc_trans]; first by exists b; split => //; exists 0.
  by apply.
Qed.

Hint Resolve tc_refl : core.

Lemma ltn_gap x y z : x < y -> y < z -> x < z.-1.
Proof.
case: z => [|z xy yz]; first by rewrite ltn0.
exact: (leq_trans xy yz).
Qed.

Lemma leq_wl v n c : v + n <= c -> v <= c.
Proof.
elim: n => [|? IH H]; first by rewrite addn0.
apply/IH/leq_trans; last apply H.
by rewrite leq_add2l.
Qed.

Lemma ltn_wl v n c : v + n < c -> v < c.
Proof.
elim: n => [|? IH H]; first by rewrite addn0.
apply/IH/ltn_trans; last apply H.
by rewrite ltn_add2l.
Qed.

End Generalities.

Inductive term :=
| Var of nat | Abs of term | App of term & term.

Local Fixpoint eq_t t1 t2 :=
  match t1, t2 with
  | Var u1, Var u2 => u1 == u2
  | Abs p1, Abs p2 => eq_t p1 p2
  | App p11 p12, App p21 p22 =>
    eq_t p11 p21 && eq_t p12 p22
  | _, _ => false
  end.
Local Lemma reflP x : eq_t x x.
Proof. elim: x => //= ? -> ? -> //; by rewrite eqxx. Qed.
Local Hint Resolve reflP : core.

Local Lemma eq_tE : Equality.axiom eq_t.
Proof.
elim=> [?|? IH|? IH1 ? IH2] []; (try by constructor) => *.
+ by apply/(iffP idP)=> [/eqP|] ->.
+ by apply/(iffP idP)=> [/IH|] ->.
+ by apply/(iffP idP)=> [/andP [] /IH1 -> /IH2|] ->.
Qed.
Definition t_eqMixin := EqMixin eq_tE.
Canonical t_eqType := Eval hnf in EqType _ t_eqMixin.

Fixpoint shift t n c :=
  match t with
  | Var v => Var (if v < c then v else v + n)
  | Abs t1 => Abs (shift t1 n c.+1)
  | App t1 t2 => App (shift t1 n c) (shift t2 n c)
  end.

Fixpoint subst t b r :=
  match t with
  | Var v =>
    if v == b then r else Var (v - (v > b))
  | Abs M => Abs (subst M b.+1 (shift r 1 0))
  | App M N => App (subst M b r) (subst N b r)
  end.

Fixpoint sizeu M :=
  match M with
  | App T N => (sizeu T + sizeu N).+1
  | Abs N => (sizeu N).+2
  | Var _ => 1
  end.

Fixpoint beta M1 M2 :=
  match M1, M2 with
  | App (Abs M as M11) M12, App M21 M22 =>
    (M11 == M21) && (beta M12 M22)
    || (beta M11 M21) && (M12 == M22)
    || (subst M 0 M12 == M2)
  | App M11 M12, App M21 M22 =>
    (M11 == M21) && (beta M12 M22)
    || (beta M11 M21) && (M12 == M22)
  | Abs M1, Abs M2 => beta M1 M2
  | App (Abs M) N, _ => subst M 0 N == M2
  | _, _  => false
  end.

Definition omega := Abs (App (Var 0) (Var 0)).
Definition K := Abs (Abs (Var 1)).

Definition wfr_term s t := sizeu s < sizeu t.

Local Lemma sizeu0 t : sizeu t == 0 = false.
Proof. elim: t => // ? IH *; by rewrite addn_eq0 IH. Qed.

Local Lemma subpattern x y :
  (forall y : term, wfr_term y x -> Acc (fun s t : term => wfr_term s t) y) ->
  sizeu y < (sizeu x).+1 -> Acc (fun s t : term => sizeu s < sizeu t) y.
Proof.
  case xy: (sizeu x == sizeu y).
   case: x xy => [?|?|??] /eqP xy IH *; constructor => ?.
   * by rewrite /wfr_term -xy /leq subSS subn0 sizeu0.
   * by rewrite /wfr_term -xy /leq subSS subn_eq0 => H; apply IH, H.
   * by rewrite /wfr_term -xy => H; apply IH, H.
  by rewrite /wfr_term ltnS leq_eqVlt eq_sym xy /= => IH H; apply IH, H.
Qed.

Local Lemma subpattern_n n x y :
  (forall y : term, wfr_term y x -> Acc (fun s t : term => wfr_term s t) y) ->
  sizeu y < sizeu x + n -> Acc (fun s t : term => sizeu s < sizeu t) y.
Proof.
  elim: (ltn_wf n) x y => {n} n _ IH x y H yxn.
  case: n IH yxn => [? yxn|[?|n IH yxn]].
  * by rewrite addn0 in yxn; apply H, yxn.
  * by rewrite addn1 => ?; apply (subpattern H).
  * apply: (IH n.+1 _ y); first by [].
    + move=> y0 y0y; apply: (IH n.+1 _ x); first by [].
      - by apply H.
      - by move: (ltn_gap y0y yxn); rewrite addnS; apply.
    +  by rewrite addnS -addSn; apply leq_addr.
Qed.

Lemma wf_wfr_term : well_founded wfr_term.
Proof.
  move=> x; constructor; elim: x => [??|? H ?|? IH ? ? ? H].
  * by rewrite /wfr_term ltnS /leq subn0 sizeu0.
  * rewrite /= /wfr_term /= -addn2.
    by apply (subpattern_n H).
  * rewrite /wfr_term /= -addnS in H.
    by apply (subpattern_n IH H).
Qed.

Local Lemma wfr_term_t_abst t : wfr_term t (Abs t).
Proof. by rewrite /wfr_term /= ltnS leqnSn. Qed.

Local Lemma wfr_term_t_appl t s : wfr_term t (App t s).
Proof. by rewrite /wfr_term /= -addSn ltn_addr. Qed.

Local Lemma wfr_term_t_appr t s : wfr_term s (App t s).
Proof. by rewrite /wfr_term /= -addnS ltn_addl. Qed.

Local Lemma wfr_term_t_app_abs t1 t2 : wfr_term t1 (App (Abs t1) t2).
Proof. by rewrite /wfr_term /= -addnS ltn_addr. Qed.

Local Lemma wfr_term_t_app_app t s u : wfr_term s (App (App t s) u).
Proof. by rewrite /wfr_term /= -!addnS ltn_addr // ltn_addl. Qed.

Local Lemma wfr_term_t_app_app_abs t s u : wfr_term t (App (App (Abs t) s) u).
Proof. by rewrite /wfr_term /= -!addnS !ltn_addr //. Qed.

Local Lemma wfr_term_t_app_app_app t s u : wfr_term t (App (App t s) u).
Proof. by rewrite /wfr_term /= -!addSn !ltn_addr //. Qed.

Lemma shiftt0 t c : shift t 0 c = t.
Proof.
by elim: t c => //= [|? IH|? IH ? IH'] *;
rewrite ?addn0 ?IH ?IH' //; case: ifP.
Qed.

Lemma shift_shift t n n' c : shift (shift t n c) n' c = shift t (n + n') c.
Proof.
elim: t n c => //= [?|? IH|? IH ? IH'] *;
rewrite ?IH ?IH' // addnA.
case: ifP => /=.
 by case: ifP => //= + /ltn_wl => ->.
by case: ifP => //= ->.
Qed.

Lemma shiftnSC t s i j :
  j <= i -> shift (shift t s i) 1 j = shift (shift t 1 j) s i.+1.
Proof.
elim: t s i j => /= [???? K|? IH|? IH ? IH'] *;
rewrite ?IH ?IH' // ?addnA.
case: ifP => /=.
 case: ifP => [? ->|H I]; first by rewrite ltnW.
 rewrite (ltn_wl I) ltnS leq_eqVlt H orbF.
 case: ifP => // /eqP ni.
 move: ni K => -> /(leq_trans I) /ltn_wl.
 by rewrite H.
case: ifP => /=.
 case: ifP => /=; first by case: ifP.
 case: ifP => //=.
 by rewrite addn1 ltnS => + ->.
case: ifP => /=;
case: ifP => /= [/(fun x => leq_trans x K) -> //|].
 by rewrite addn1 ltnS => + ->.
by rewrite !addn1 addSn.
Qed.

Lemma betaE t1 t2 : beta (App (Abs t1) t2) (subst t1 0 t2).
Proof.
elim: t1 t2 => //= [? []|] *;
by rewrite ?eqxx; try case: ifP => //; rewrite orbT.
Qed.

Definition betat := tc beta.

Definition betat_trans := @tc_trans _ beta.

Lemma beta_abs M N : beta (Abs M) N -> exists M', N = (Abs M') /\ beta M M'.
Proof. by case: N M => // ? ? H; repeat apply: ex_intro. Qed.

Lemma betat_refl a : betat a a.
Proof. apply tc_refl. Qed.

Lemma beta_betat a b : beta a b -> betat a b.
Proof. move=> *; by exists 1. Qed.

Lemma beta_id t : beta (App (Abs (Var 0)) t) t.
Proof.
case: t => //= [] //= *.
by rewrite eqxx orbT.
Qed.

Lemma tcn_betat s t n : tcn beta n s t -> betat s t.
Proof. move=> *; by exists n. Qed.

Hint Resolve wfr_term_t_abst wfr_term_t_appl
      wfr_term_t_app_app_abs wfr_term_t_app_app
      wfr_term_t_app_app_app wfr_term_t_appr wfr_term_t_app_abs
      beta_betat betat_refl betaE beta_id : core.

Lemma betat_abs M N : betat (Abs M) N -> exists M', N = Abs M' /\ betat M M'.
Proof.
case; case => // [H|n]; first by exists M.
elim: n M N => [? [] // t|n IH M N]; first by exists t; auto.
rewrite tcnS => [][] ? [] /(IH _ _) [] t [] -> Mt /beta_abs [] s [] -> ts.
exists s; split => //; by apply/(betat_trans Mt)/beta_betat.
Qed.

Lemma betatAC p p' :
  betat (Abs p) (Abs p') <-> betat p p'.
Proof.
split.
* case; case => [[] -> //|[|n H]]; auto.
  elim: (ltn_wf n) p p' H => {n} [] [_ _ ? ? [] x []|n _ IH p p'].
   case:x => //= ? a ?; by apply: betat_trans;apply beta_betat;first by apply a.
  case: n IH => // [_ [] x [][] y []|n IH].
   case: y x => // ? [] ? // /= a b c.
   apply/(betat_trans (beta_betat a))
        /(betat_trans (beta_betat b) (beta_betat c)).
  rewrite tcSn => [][] x []; case: x => // ? /= a b.
  by apply/(betat_trans (beta_betat a))/(IH n.+1).
* case=> x; elim: (ltn_wf x) p p' => {x} x _ IH p p'.
  case: x IH => [? ->|[*|n IH [] c [] *]]; auto.
  apply: betat_trans; last by apply: (_ : betat (Abs c) _); auto.
  by apply: (IH n.+1).
Qed.

Lemma betatApC p2 p2' p1 p1' :
  betat p1 p1' -> betat p2 p2' -> betat (App p1 p2) (App p1' p2').
Proof.
  move=> H1; case => x H2.
  elim: (ltn_wf x) p2 p2' p1 p1' H2 H1 => {x} x _ IH p2 p2' p1 p1' H2 H1.
  case: x H2 IH => /= [-> _|[H |n [c [] H ?]] IH].
  + case: H1 => // y H1.
    elim: y p1 p1' p2 p2' H1 => [???? ->//|y IH p1 ?? p2' H].
    case: y H IH => [H _|[[] x [] ?? IH|y [] c [] H H1 IH]].
    * by apply: beta_betat; rewrite /= H eqxx !orbT; case: p1 H.
    * by apply/(betat_trans (IH p1 x p2' _ _))/IH.
    * apply: betat_trans; first by apply/(IH p1 c c)/H.
      by apply/beta_betat; rewrite /= !eqxx !H1 !orbT;
         case: c H1 H => // *; rewrite !orbT.
  + apply: betat_trans.
     apply/(_ : betat _ (App p1 p2'))/beta_betat.
     rewrite /= H eqxx.
     by case: p1 H1.
    by apply/(IH 0).
  + apply: betat_trans.
     by apply/(_ : betat _ (App p1' c))/(IH n.+1).
    by apply/(IH 1).
Qed.

Example beta_app_omega : beta (App omega omega) (App omega omega).
Proof. by []. Qed.

Fixpoint compute_parallel t :=
  match t with
  | Var x => [:: t]
  | Abs M => map Abs (compute_parallel M)
  | App (Abs t1) t2 =>
    let t1s := compute_parallel t1 in
    let t2s := compute_parallel t2 in
    [seq subst s1 0 s2 | s1 <- t1s, s2 <- t2s]
    ++ [seq App (Abs s1) s2 | s1 <- t1s, s2 <- t2s]
  | App t1 t2 =>
    [seq App s1 s2 | s1 <- compute_parallel t1, s2 <- compute_parallel t2]
  end.

Inductive parallel_spec : term -> term -> Prop :=
| VarVar : forall x y, x = y -> parallel_spec (Var x) (Var y)
| AbsAbs : forall x y, parallel_spec x y -> parallel_spec (Abs x) (Abs y)
| AppApp : forall t1 t2 s1 s2, parallel_spec t1 s1 -> parallel_spec t2 s2
                         -> parallel_spec (App t1 t2) (App s1 s2)
| AppAbs : forall t1 t2 s1 s2, parallel_spec t1 s1 -> parallel_spec t2 s2
                         -> parallel_spec (App (Abs t1) t2) (subst s1 0 s2).

Definition parallel t s := s \in compute_parallel t.

Local Lemma inf (T : eqType) (s1 : T) f ts :
  s1 \in [seq f s2 | s2 <- ts] ->
  exists s2 : term, s1 = f s2 /\ s2 \in ts.
Proof.
  elim: ts => // a ts IH.
  rewrite /= !in_cons.
  case/orP => [/eqP ->|/IH [] b [] -> b0].
  exists a; by rewrite in_cons eqxx.
  exists b; by rewrite in_cons b0 orbT.
Qed.

Local Lemma inj_app x : injective (App x).
Proof. by move=> ? ? []. Qed.

Local Lemma inj_abs : injective Abs.
Proof. by move=> ? ? []. Qed.

Local Lemma pat1 s n : (s < n) <= n.
Proof.
  case sn : (s < n) => //.
  case: s sn => // s.
  by apply/ltn_trans.
Qed.

Local Lemma pat7 n j i : n - (j < n) < i -> i < n -> false.
Proof.
  case: n => // n.
  case: (j < n.+1).
   by rewrite subn1 leqNgt /= => /negPf ->.
  rewrite subn0 ltnNge => + ?.
  by rewrite ltnW.
Qed.

Local Hint Resolve inj_abs inj_app pat1 : core.
Hint Constructors parallel_spec : core.

Lemma subst_in s1 s2 t2 i :
  s2 \in t2 -> subst s1 i s2 \in [seq subst s1 i s0 | s0 <- t2].
Proof.
  elim: t2 s1 s2 i => // ?? H ???.
  rewrite !in_cons => /orP [/eqP>|/H] ->;
  by rewrite ?eqxx ?orbT.
Qed.

Lemma parallelt0 t : compute_parallel t == [::] = false.
Proof.
  elim: t => //= [t <-| t1 IH1 t2 IH2].
  by elim: (compute_parallel t).
  case: (compute_parallel t2) IH2 => //= ?? _.
  case: t1 IH1 => // [t <- /=| t1 t1' <-].
   by elim: (compute_parallel t).
  by elim: (compute_parallel (App t1 t1')).
Qed.

Lemma parallelP t s : parallel_spec t s <-> parallel t s.
Proof.
split.
* elim => [?? ->|*| |?? s1 *].
  - by rewrite /parallel mem_seq1.
  - by rewrite /parallel mem_map.
  - case => [n ???|???? _ H1 _ ?|??? s1 ??? H1 ?].
    + rewrite /parallel mem_seq1 => ? /eqP ->.
      by rewrite /= cats0 mem_map.
    + rewrite /parallel mem_cat.
      apply/orP; right; apply/flatten_mapP.
      case/inf: H1 => s1' [] -> b0.
      apply/ex_intro2; first apply b0.
      by rewrite mem_map.
    + apply/flatten_mapP/(ex_intro2 _ _ s1).
      by inversion H1.
      by rewrite mem_map.
  - rewrite /parallel /= mem_cat.
    apply/orP; left; apply/flatten_mapP.
    by apply/(ex_intro2 _ _ s1)/subst_in.
* elim: (wf_wfr_term t) s => {t} t _ IH.
  case: t IH => [?? []// ?|? IH ? /inf [] s [] -> /IH|[????|????|?????]]; auto.
  - rewrite /parallel mem_seq1 => /eqP ->; auto.
  - rewrite /parallel /= cats0 => /inf [] ? [] -> ?.
    by auto.
  - rewrite /parallel /= mem_cat => /orP [] /flatten_mapP [] ?? /inf []?[]->?;
    by auto.
  - case/flatten_mapP => [] ? [] ? /inf [] ? [] -> ?.
    by auto.
Qed.

Lemma paralleltt t : parallel t t.
Proof.
  apply/parallelP.
  elim: (wf_wfr_term t) => {t} t _ IHt.
  by case: t IHt => *; constructor; auto.
Qed.

Lemma parallel_id t s :
  parallel t s -> parallel (App (Abs (Var 0)) t) s.
Proof.
elim: t s => [??|? IH ? /inf [] ? [] -> H|t IH1 ? IH2 ?].
* rewrite /parallel mem_seq1 => /eqP ->.
  by rewrite /parallel in_cons /= eqxx.
* rewrite /parallel /= map_id !cats0 mem_cat; apply/orP; left.
  by rewrite mem_map.
* case: t IH1 => [??|??|???].
+ rewrite /parallel /= cats0 => /inf [] ? [] -> H.
  rewrite map_id !cats0 !mem_cat; apply/orP; left.
  by rewrite mem_map.
+ rewrite /parallel /= map_id !cats0 !mem_cat
   => /orP [] /flatten_mapP [] ? p /inf []?[] -> ?.
   apply/orP; left; apply/orP; left.
   by apply/flatten_mapP/ex_intro2/subst_in.
  apply/orP; left; apply/orP; right.
  apply/flatten_mapP/ex_intro2; first by apply/p.
  by rewrite mem_map.
+ rewrite /parallel /= !cats0 map_id mem_cat
   => /flatten_mapP [] ? p /inf []?[] -> ?.
  apply/orP; left.
  apply/flatten_mapP/ex_intro2; first by apply/p.
  by rewrite mem_map.
Qed.

Hint Resolve paralleltt (fun t => iffRL (parallelP t t) (paralleltt t))
     parallel_id : core.

Lemma beta_parallel t s : beta t s -> parallel t s.
Proof.
move=> H; apply/parallelP.
elim: (wf_wfr_term t) s H => {t} t _ IHt.
case: t IHt => // [? ? [] //= ? ?|];
first by auto.
case => [?? IH [] //?? /orP[]// /andP[]/eqP <- /IH ?|t1 t2 ? s /=|??? IH []// ??].
* by auto.
* case t12s: (subst t1 0 t2 == s).
   move/eqP: t12s => <- ?.
   by auto.
  case: s t12s => []//[]// ?? _ /orP []//.
  case/orP => /andP [] => [/eqP <- ?|? /eqP <-]; by auto.
* case/orP => /andP [] => [/eqP <- ?|? /eqP <-]; by auto.
Qed.

Lemma shift_substC s1 s2 s i j :
i <= j -> shift (subst s1 j s2) s i = subst (shift s1 s i) (j + s) (shift s2 s i).
Proof.
  elim: s1 s2 s i j.
  move=> ????? /=.
  case: ifP.
   move/eqP ->.
   rewrite leqNgt => /negPf ->.
   by rewrite eqxx.
  case: ifP.
   case: ifP => [+ /eqP njs|].
    move: njs => -> /ltn_wl.
    by rewrite ltnNge => /negPf ->.
   by rewrite eqn_add2r => + ->.
  case: ifP => /=.
   case: ifP => [_ ni ?? /(leq_trans ni) nj|/negP/negP + ni].
    by rewrite !ltnNge ltnW // ltnW // ltn_addr.
   by rewrite (leq_ltn_trans (leq_subr _ _) ni).
  move/negP/negP.
  rewrite -ltnNge ltnS ltn_add2r leq_eqVlt.
  case/orP => [/eqP -> ??|].
   rewrite leqNgt => /negPf ->.
   by rewrite !subn0 ltnn.
  case: ifP => [/pat7 H /H //|?????].
  by rewrite addnC addnBA // addnC.

  move=> ? IH ???? ?.
  by rewrite /= IH // addSn shiftnSC.

  move=> ? IH1 ? IH2 ?????.
  by rewrite /= IH1 // IH2.
Qed.

Lemma shift_substC' s1 s2 s i j :
j <= i -> shift (subst s1 j s2) s i = subst (shift s1 s i.+1) j (shift s2 s i).
Proof.
  elim: s1 s2 s i j.
  move=> ?? s i ? /=.
  case: ifP.
   move/eqP -> => H.
   by rewrite ltnS H eqxx.
  case: ifP.
   case: ifP => [+ ->|] // + /eqP <-.
   case: s => [|s]; first by rewrite addn0 eqxx.
   case: i => [|i].
    by rewrite addnC => ?? /leq_wl.
   rewrite addnS !ltnS => + + /leq_wl H.
   by rewrite ltnW.
  case: ifP => /=.
   rewrite ltnS leq_eqVlt => /orP [/eqP ->|ni].
    case: i => [|i].
     by rewrite leqn0 eq_sym => ->.
    rewrite leq_eqVlt eq_sym => -> _ /orP []// ->.
    by rewrite subn1 ltnSn.
   by rewrite (leq_ltn_trans (leq_subr _ _) ni).
  move/negP/negP.
  rewrite -ltnNge ltnS.
  case: ifP => [/pat7 H /H //|] _ + _ _ /leq_ltn_trans H => /H H'.
  by rewrite addnC addnBA // H' ltn_addr // addnC.

  move=> ? IH ???? ?.
  by rewrite /= IH // shiftnSC.

  move=> ? IH1 ? IH2 ?????.
  by rewrite /= IH1 // IH2.
Qed.

Lemma shift_pres_parallel u u' s i :
  parallel u u' -> parallel (shift u s i) (shift u' s i).
Proof.
  move/parallelP => H; apply/parallelP.
  elim: u u' / H s i => [?? ->|||] // *; try constructor; auto.
  by rewrite /= shift_substC'; auto.
Qed.

Lemma subst0 t s j k :
subst (shift t j.+1 k) (j + k) s = shift t j k.
Proof.
  elim: t s j k => [|? H1|? IH1 ? IH2] * /=.
  * case: ifP.
     case: ifP => [+ /eqP nk|].
      rewrite nk addnC => /ltn_wl.
      by rewrite ltnn.
     rewrite addnS -addSn addnC eqn_add2l => + /eqP nk.
     by rewrite -nk ltnSn.
    case: ifP => [*|/negP/negP]; first by rewrite ltnNge ltnW ?ltn_addl // subn0.
    rewrite -ltnNge => H ?.
    by rewrite addnS -addSn addnC ltn_add2l H subn1 addnS addnC.
  * by rewrite -addnS H1.
  * by rewrite IH1 IH2.
Qed.

Lemma subst0' z w i : subst (shift z 1 i) i w = z.
Proof.
elim: z w i => /= [n ? i|? IHt ??|? IHt1 ? IHt2 ??]; last first.
* by rewrite IHt1 IHt2.
* by rewrite IHt.
* case ni: (n < i).
  case: ifP => [/eqP ni'|].
   move: ni' ni => ->.
   by rewrite ltnn.
  by rewrite ltnNge ltnW // subn0.
  case: ifP => [/eqP ni'|].
   move: ni' ni => <-.
   by rewrite addn1 ltnS leqnn.
  by rewrite addn1 ltnS leqNgt ni subn1.
Qed.

Lemma subst_substC j t1 t2 t s :
  subst (subst t1 j (shift t2 j 0)) (s + j) (shift t j 0)
= subst (subst t1 (s + j).+1 (shift t j.+1 0))
      j (subst (shift t2 j 0) (s + j) (shift t j 0)).
Proof.
elim: t1 t2 t s j.
 case.
  move=> * /=.
  rewrite !sub0n.
  case: ifP => /= [/eqP <-|j0]; first by rewrite /= addn0 shiftt0.
  by rewrite eq_sym addn_eq0 andbC eq_sym j0 /= sub0n.
 move=> n t2 t s j.
  rewrite /= eqSS.
  case: ifP.
   move/eqP <-.
   rewrite addnS -addSn -[n in n == _]add0n eqn_add2r /=.
   by rewrite ltnS ltnNge leq_addl subn0 eqxx.
  case: ifP => /=.
   move/eqP ->.
   rewrite /= ltnS leq_addl subn1 eqxx.
   by rewrite -[j in subst _ j _]addn0 subst0.
  rewrite !ltnS.
  case: ifP.
   case jn: (j <= n).
    by rewrite subn1 => ->.
   rewrite subn0 => /eqP nssj + nsj.
   have: (n.+1 < j).
    by rewrite ltn_neqAle nsj ltnNge jn.
   rewrite nssj addnC => /ltn_wl.
   by rewrite ltnn.
  case: ifP.
   case sjn: (s + j < n).
    rewrite subn1 => /eqP nj.
    move: nj sjn => <-.
    rewrite addnC => /ltn_wl.
    by rewrite ltnn.
   by rewrite subn0 => ->.
  case jn : (j < n).
   case sjn: (s + j < n).
    by rewrite ltnW // !subn1 /= jn sjn.
   by rewrite /= !subn0 !ltnS ltnW // subn1 sjn subn0.
  case sjn: (s + j < n).
   rewrite subn1 /= leq_eqVlt jn eq_sym => ->.
   by rewrite /= subn0 ltnW.
  rewrite subn0 ltnS.
  case jn': (j <= n).
   by rewrite subn1 sjn subn0.
  rewrite subn0 ltnS leq_eqVlt sjn orbF => _ _.
  rewrite eq_sym => ->; by rewrite subn0.
 move=> ? IH ????.
 by rewrite /= !shift_shift shift_substC // !addn1 -addnS IH !shift_shift addn1.

 move=> ? IH1 ? IH2 ????.
 by rewrite /= IH1 IH2.
Qed.

Lemma subst_pres_parallel u u' s t t' :
  parallel t t' -> parallel u u' -> parallel (subst u s t) (subst u' s t').
Proof.
move=> /parallelP H /parallelP I; apply/parallelP.
elim: u u'/ I t t' s H => [?? -> * /=|??? H0 *||]; first by case: ifP.
* by constructor; apply/H0/parallelP/shift_pres_parallel/parallelP.
* by constructor; auto.
* move=> t1 t2 s1 s2 t1s1 IH1 t2s2 IH2 t t' s H.
  move: (subst_substC 0 s1 s2 t' s).
  rewrite !addn0 !shiftt0 => ->.
  constructor; auto.
  by apply/IH1/parallelP/shift_pres_parallel/parallelP.
Qed.

Lemma parallel_betat t s : parallel t s -> betat t s.
Proof.
  move/parallelP; elim => [??->|||]* //.
  * by apply/betatAC.
  * by apply/betatApC.
  * apply/betat_trans/beta_betat/betaE.
    by apply/betatApC; rewrite // betatAC.
Qed.

Definition parallelt := tc parallel.
Lemma parallelt_refl a : parallelt a a.
Proof. apply tc_refl. Qed.
Lemma parallel_parallelt t s : parallel t s -> parallelt t s.
Proof. by move=> ?; exists 1. Qed.
Hint Resolve parallelt_refl : core.

Lemma parallelt_betatP t s : parallelt t s <-> betat t s.
Proof.
  split; case=> x; elim: x t s => [?? -> //|? IH ??];
  rewrite tcnS => [][]?[] /IH.
   by move=> + /parallel_betat; apply/tc_trans.
  by move=> + /beta_parallel/parallel_parallelt; apply/tc_trans.
Qed.

Fixpoint cr t :=
  match t with
  | Abs s => Abs (cr s)
  | Var v => Var v
  | App (Abs u) v => subst (cr u) 0 (cr v)
  | App u v => App (cr u) (cr v)
  end.

Lemma CR_parallel N1 : forall M1, parallel N1 M1 -> parallel M1 (cr N1).
Proof.
  move=> M1 /parallelP H; apply/parallelP.
  elim: N1 M1 / H => [?? ->|*|[*| |*]|*] /=; auto;
   last by apply/parallelP/subst_pres_parallel; apply/parallelP.
  move=> ?? + ? /parallelP /inf []+[]-> => _ ? /parallelP ? /parallelP.
  by rewrite /parallel /= mem_map // => /parallelP ???; auto.
Qed.

Lemma sCR_parallel N1 M1 M2 :
  parallelt N1 M1 -> parallel N1 M2 -> exists N2, parallel M1 N2 /\ parallelt M2 N2.
Proof.
case => x; elim: x N1 M1 => [? M1 -> ?|x H N1 M1].
 by exists (cr M1); split; [|apply/parallel_parallelt]; apply/CR_parallel.
rewrite tcnS => [][] y [] /H {H} H ? /H {H} []?[] H ?.
exists (cr y); split; first by apply/CR_parallel.
by apply/tc_trans/parallel_parallelt/CR_parallel/H.
Qed.

Lemma CR_parallelt N1 M1 M2 :
  parallelt N1 M1 -> parallelt N1 M2 -> exists N2, parallelt M1 N2 /\ parallelt M2 N2.
Proof.
  move=> +[] x; elim: x N1 M1 M2 => [? M1 ? + <-|x IH N1 M1 M2 NM];
   first by exists M1; auto.
  rewrite tcnS => [][] x0 [] /IH H; move/H: NM => {H}.
  case=> ? [] H0 /sCR_parallel H /H {H} [] y [] H1 H2.
  exists (cr y); split.
   by apply/(tc_trans H0)/(tc_trans (parallel_parallelt H1))
           /parallel_parallelt/CR_parallel.
  by apply/(tc_trans H2)/parallel_parallelt/CR_parallel.
Qed.

Lemma CR M1 M2 N1 : betat N1 M1 -> betat N1 M2 -> exists N2, betat M1 N2 /\ betat M2 N2.
Proof.
move=> /parallelt_betatP H1 /parallelt_betatP H2.
by case: (CR_parallelt H1 H2) => x [] p1 p2; exists x; split; apply /parallelt_betatP.
Qed.
\end{verbatim}
\end{quote}
\end{document}
